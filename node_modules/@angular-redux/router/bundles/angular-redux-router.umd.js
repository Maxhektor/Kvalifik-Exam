(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular-redux/store'), require('@angular/common'), require('@angular/core'), require('@angular/router'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@angular-redux/router', ['exports', '@angular-redux/store', '@angular/common', '@angular/core', '@angular/router', 'rxjs/operators'], factory) :
    (factory((global['angular-redux'] = global['angular-redux'] || {}, global['angular-redux'].router = {}),global.angularReduxStore,global.ng.common,global.ng.core,global.ng.router,global.rxjs.operators));
}(this, (function (exports,store,common,core,router,operators) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var UPDATE_LOCATION = '@angular-redux/router::UPDATE_LOCATION';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DefaultRouterState = '';
    /**
     * @param {?=} state
     * @param {?=} action
     * @return {?}
     */
    function routerReducer(state, action) {
        if (state === void 0) {
            state = DefaultRouterState;
        }
        switch (action.type) {
            case UPDATE_LOCATION:
                return action.payload || DefaultRouterState;
            default:
                return state;
        }
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgReduxRouter = /** @class */ (function () {
        function NgReduxRouter(router$$1, ngRedux, location) {
            this.router = router$$1;
            this.ngRedux = ngRedux;
            this.location = location;
            this.initialized = false;
            this.selectLocationFromState = function (state) {
                return state.router;
            };
        }
        /**
         * Destroys the bindings between @angular-redux/router and @angular/router.
         * This method unsubscribes from both @angular-redux/router and @angular router, in case
         * your app needs to tear down the bindings without destroying Angular or Redux
         * at the same time.
         */
        /**
         * Destroys the bindings between \@angular-redux/router and \@angular/router.
         * This method unsubscribes from both \@angular-redux/router and \@angular router, in case
         * your app needs to tear down the bindings without destroying Angular or Redux
         * at the same time.
         * @return {?}
         */
        NgReduxRouter.prototype.destroy = /**
         * Destroys the bindings between \@angular-redux/router and \@angular/router.
         * This method unsubscribes from both \@angular-redux/router and \@angular router, in case
         * your app needs to tear down the bindings without destroying Angular or Redux
         * at the same time.
         * @return {?}
         */
            function () {
                if (this.urlStateSubscription) {
                    this.urlStateSubscription.unsubscribe();
                }
                if (this.reduxSubscription) {
                    this.reduxSubscription.unsubscribe();
                }
                this.initialized = false;
            };
        /**
         * Initialize the bindings between @angular-redux/router and @angular/router
         *
         * This should only be called once for the lifetime of your app, for
         * example in the constructor of your root component.
         *
         *
         * @param selectLocationFromState Optional: If your
         * router state is in a custom location, supply this argument to tell the
         * bindings where to find the router location in the state.
         * @param urlState$ Optional: If you have a custom setup
         * when listening to router changes, or use a different router than @angular/router
         * you can supply this argument as an Observable of the current url state.
         */
        /**
         * Initialize the bindings between \@angular-redux/router and \@angular/router
         *
         * This should only be called once for the lifetime of your app, for
         * example in the constructor of your root component.
         *
         *
         * @param {?=} selectLocationFromState Optional: If your
         * router state is in a custom location, supply this argument to tell the
         * bindings where to find the router location in the state.
         * @param {?=} urlState$ Optional: If you have a custom setup
         * when listening to router changes, or use a different router than \@angular/router
         * you can supply this argument as an Observable of the current url state.
         * @return {?}
         */
        NgReduxRouter.prototype.initialize = /**
         * Initialize the bindings between \@angular-redux/router and \@angular/router
         *
         * This should only be called once for the lifetime of your app, for
         * example in the constructor of your root component.
         *
         *
         * @param {?=} selectLocationFromState Optional: If your
         * router state is in a custom location, supply this argument to tell the
         * bindings where to find the router location in the state.
         * @param {?=} urlState$ Optional: If you have a custom setup
         * when listening to router changes, or use a different router than \@angular/router
         * you can supply this argument as an Observable of the current url state.
         * @return {?}
         */
            function (selectLocationFromState, urlState$) {
                if (selectLocationFromState === void 0) {
                    selectLocationFromState = function (state) { return state.router; };
                }
                if (this.initialized) {
                    throw new Error('@angular-redux/router already initialized! If you meant to re-initialize, call destroy first.');
                }
                this.selectLocationFromState = selectLocationFromState;
                this.urlState = urlState$ || this.getDefaultUrlStateObservable();
                this.listenToRouterChanges();
                this.listenToReduxChanges();
                this.initialized = true;
            };
        /**
         * @private
         * @return {?}
         */
        NgReduxRouter.prototype.getDefaultUrlStateObservable = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                return this.router.events.pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd; }), operators.map(function () { return _this.location.path(); }), operators.distinctUntilChanged());
            };
        /**
         * @private
         * @param {?=} useInitial
         * @return {?}
         */
        NgReduxRouter.prototype.getLocationFromStore = /**
         * @private
         * @param {?=} useInitial
         * @return {?}
         */
            function (useInitial) {
                if (useInitial === void 0) {
                    useInitial = false;
                }
                return (this.selectLocationFromState(this.ngRedux.getState()) ||
                    (useInitial ? this.initialLocation : ''));
            };
        /**
         * @private
         * @return {?}
         */
        NgReduxRouter.prototype.listenToRouterChanges = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var handleLocationChange = function (location) {
                    if (_this.currentLocation === location) {
                        // Dont dispatch changes if we haven't changed location.
                        return;
                    }
                    _this.currentLocation = location;
                    if (_this.initialLocation === undefined) {
                        _this.initialLocation = location;
                        // Fetch initial location from store and make sure
                        // we dont dispath an event if the current url equals
                        // the initial url.
                        /** @type {?} */
                        var locationFromStore = _this.getLocationFromStore();
                        if (locationFromStore === _this.currentLocation) {
                            return;
                        }
                    }
                    _this.ngRedux.dispatch({
                        type: UPDATE_LOCATION,
                        payload: location,
                    });
                };
                if (this.urlState) {
                    this.urlStateSubscription = this.urlState.subscribe(handleLocationChange);
                }
            };
        /**
         * @private
         * @return {?}
         */
        NgReduxRouter.prototype.listenToReduxChanges = /**
         * @private
         * @return {?}
         */
            function () {
                var _this = this;
                /** @type {?} */
                var handleLocationChange = function (location) {
                    if (_this.initialLocation === undefined) {
                        // Wait for router to set initial location.
                        return;
                    }
                    /** @type {?} */
                    var locationInStore = _this.getLocationFromStore(true);
                    if (_this.currentLocation === locationInStore) {
                        // Dont change router location if its equal to the one in the store.
                        return;
                    }
                    _this.currentLocation = location;
                    _this.router.navigateByUrl(location);
                };
                this.reduxSubscription = this.ngRedux
                    .select(function (state) { return _this.selectLocationFromState(state); })
                    .pipe(operators.distinctUntilChanged())
                    .subscribe(handleLocationChange);
            };
        NgReduxRouter.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NgReduxRouter.ctorParameters = function () {
            return [
                { type: router.Router },
                { type: store.NgRedux },
                { type: common.Location }
            ];
        };
        return NgReduxRouter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgReduxRouterModule = /** @class */ (function () {
        function NgReduxRouterModule() {
        }
        /**
         * @return {?}
         */
        NgReduxRouterModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: NgReduxRouterModule,
                    providers: [NgReduxRouter],
                };
            };
        NgReduxRouterModule.decorators = [
            { type: core.NgModule }
        ];
        return NgReduxRouterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.NgReduxRouterModule = NgReduxRouterModule;
    exports.NgReduxRouter = NgReduxRouter;
    exports.routerReducer = routerReducer;
    exports.UPDATE_LOCATION = UPDATE_LOCATION;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=angular-redux-router.umd.js.map