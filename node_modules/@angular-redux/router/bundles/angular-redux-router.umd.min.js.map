{"version":3,"sources":["ng://@angular-redux/router/actions.ts","ng://@angular-redux/router/router.ts","ng://@angular-redux/router/index.ts","ng://@angular-redux/router/reducer.ts"],"names":["UPDATE_LOCATION","NgReduxRouter","router","ngRedux","location","this","initialized","selectLocationFromState","state","prototype","destroy","urlStateSubscription","unsubscribe","reduxSubscription","initialize","urlState$","Error","urlState","getDefaultUrlStateObservable","listenToRouterChanges","listenToReduxChanges","_this","events","pipe","filter","event","NavigationEnd","map","path","distinctUntilChanged","getLocationFromStore","useInitial","getState","initialLocation","subscribe","currentLocation","undefined","dispatch","type","payload","select","locationInStore","navigateByUrl","Injectable","Router","NgRedux","Location","NgReduxRouterModule","forRoot","ngModule","providers","NgModule","routerReducer","action"],"mappings":"okBAAA,IAAaA,EAA0B,yCCAvC,IAAAC,EAAA,WAkBE,SAAAA,EACUC,EACAC,EACAC,GAFAC,KAAAH,OAAAA,EACAG,KAAAF,QAAAA,EACAE,KAAAD,SAAAA,EAXFC,KAAAC,aAAc,EAiEdD,KAAAE,wBAAkD,SAAAC,GACxD,OAAAA,EAAMN,QAsEV,OApHED,EAAAQ,UAAAC,QAAA,WACML,KAAKM,sBACPN,KAAKM,qBAAqBC,cAGxBP,KAAKQ,mBACPR,KAAKQ,kBAAkBD,cAGzBP,KAAKC,aAAc,GAiBrBL,EAAAQ,UAAAK,WAAA,SACEP,EACAQ,GAEA,QAHA,IAAAR,IAAAA,EAAA,SAAkDC,GAAS,OAAAA,EAAMN,SAG7DG,KAAKC,YACP,MAAM,IAAIU,MACR,iGAIJX,KAAKE,wBAA0BA,EAE/BF,KAAKY,SAAWF,GAAaV,KAAKa,+BAElCb,KAAKc,wBACLd,KAAKe,uBACLf,KAAKC,aAAc,GAMbL,EAAAQ,UAAAS,6BAAR,WAAA,IAAAG,EAAAhB,KACE,OAAOA,KAAKH,OAAOoB,OAAOC,KACxBC,EAAAA,OAAO,SAAAC,GAAS,OAAAA,aAAiBC,EAAAA,gBACjCC,EAAAA,IAAI,WAAM,OAAAN,EAAKjB,SAASwB,SACxBC,EAAAA,yBAII5B,EAAAQ,UAAAqB,qBAAR,SAA6BC,GAC3B,YAD2B,IAAAA,IAAAA,GAAA,GAEzB1B,KAAKE,wBAAwBF,KAAKF,QAAQ6B,cACzCD,EAAa1B,KAAK4B,gBAAkB,KAIjChC,EAAAQ,UAAAU,sBAAR,WAAA,IAAAE,EAAAhB,KA0BMA,KAAKY,WACPZ,KAAKM,qBAAuBN,KAAKY,SAASiB,UA1Bf,SAAC9B,GAC5B,GAAIiB,EAAKc,kBAAoB/B,EAA7B,CAMA,GADAiB,EAAKc,gBAAkB/B,EACnBiB,EAAKY,kBAAoBG,YAC3Bf,EAAKY,gBAAkB7B,EAKGiB,EAAKS,yBACLT,EAAKc,iBAC7B,OAIJd,EAAKlB,QAAQkC,SAAS,CACpBC,KAAMtC,EACNuC,QAASnC,SASPH,EAAAQ,UAAAW,qBAAR,WAAA,IAAAC,EAAAhB,KAiBEA,KAAKQ,kBAAoBR,KAAKF,QAC3BqC,OAAO,SAAAhC,GAAS,OAAAa,EAAKd,wBAAwBC,KAC7Ce,KAAKM,EAAAA,wBACLK,UAnB0B,SAAC9B,GAC5B,GAAIiB,EAAKY,kBAAoBG,UAA7B,KAKMK,EAAkBpB,EAAKS,sBAAqB,GAC9CT,EAAKc,kBAAoBM,IAK7BpB,EAAKc,gBAAkB/B,EACvBiB,EAAKnB,OAAOwC,cAActC,4BAlI/BuC,EAAAA,sDALuBC,EAAAA,cAHfC,EAAAA,eACAC,EAAAA,YAiJT7C,EAlJA,GCAA8C,EAAA,WAKA,SAAAA,KAQA,OANSA,EAAAC,QAAP,WACE,MAAO,CACLC,SAAUF,EACVG,UAAW,CAACjD,yBALjBkD,EAAAA,WAQDJ,EAbA,6DCUA,SAAgBK,EACd5C,EACA6C,GAEA,YAHA,IAAA7C,IAAAA,EAPwC,IAUhC6C,EAAOf,MACb,KAAKtC,EACH,OAAOqD,EAAOd,SAZsB,GAatC,QACE,OAAO/B","sourcesContent":["export const UPDATE_LOCATION: string = '@angular-redux/router::UPDATE_LOCATION';\n","import { NgRedux } from '@angular-redux/store';\nimport { Location } from '@angular/common';\nimport { Injectable } from '@angular/core';\nimport { NavigationEnd, Router } from '@angular/router';\nimport { Observable, Subscription } from 'rxjs';\nimport { distinctUntilChanged, filter, map } from 'rxjs/operators';\nimport { UPDATE_LOCATION } from './actions';\n\n@Injectable()\nexport class NgReduxRouter {\n  private initialized = false;\n  private currentLocation?: string;\n  private initialLocation?: string;\n  private urlState?: Observable<string>;\n\n  private urlStateSubscription?: Subscription;\n  private reduxSubscription?: Subscription;\n\n  constructor(\n    private router: Router,\n    private ngRedux: NgRedux<any>,\n    private location: Location,\n  ) {}\n\n  /**\n   * Destroys the bindings between @angular-redux/router and @angular/router.\n   * This method unsubscribes from both @angular-redux/router and @angular router, in case\n   * your app needs to tear down the bindings without destroying Angular or Redux\n   * at the same time.\n   */\n  destroy() {\n    if (this.urlStateSubscription) {\n      this.urlStateSubscription.unsubscribe();\n    }\n\n    if (this.reduxSubscription) {\n      this.reduxSubscription.unsubscribe();\n    }\n\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize the bindings between @angular-redux/router and @angular/router\n   *\n   * This should only be called once for the lifetime of your app, for\n   * example in the constructor of your root component.\n   *\n   *\n   * @param selectLocationFromState Optional: If your\n   * router state is in a custom location, supply this argument to tell the\n   * bindings where to find the router location in the state.\n   * @param urlState$ Optional: If you have a custom setup\n   * when listening to router changes, or use a different router than @angular/router\n   * you can supply this argument as an Observable of the current url state.\n   */\n  initialize(\n    selectLocationFromState: (state: any) => string = state => state.router,\n    urlState$?: Observable<string> | undefined,\n  ) {\n    if (this.initialized) {\n      throw new Error(\n        '@angular-redux/router already initialized! If you meant to re-initialize, call destroy first.',\n      );\n    }\n\n    this.selectLocationFromState = selectLocationFromState;\n\n    this.urlState = urlState$ || this.getDefaultUrlStateObservable();\n\n    this.listenToRouterChanges();\n    this.listenToReduxChanges();\n    this.initialized = true;\n  }\n\n  private selectLocationFromState: (state: any) => string = state =>\n    state.router;\n\n  private getDefaultUrlStateObservable() {\n    return this.router.events.pipe(\n      filter(event => event instanceof NavigationEnd),\n      map(() => this.location.path()),\n      distinctUntilChanged(),\n    );\n  }\n\n  private getLocationFromStore(useInitial: boolean = false) {\n    return (\n      this.selectLocationFromState(this.ngRedux.getState()) ||\n      (useInitial ? this.initialLocation : '')\n    );\n  }\n\n  private listenToRouterChanges() {\n    const handleLocationChange = (location: string) => {\n      if (this.currentLocation === location) {\n        // Dont dispatch changes if we haven't changed location.\n        return;\n      }\n\n      this.currentLocation = location;\n      if (this.initialLocation === undefined) {\n        this.initialLocation = location;\n\n        // Fetch initial location from store and make sure\n        // we dont dispath an event if the current url equals\n        // the initial url.\n        const locationFromStore = this.getLocationFromStore();\n        if (locationFromStore === this.currentLocation) {\n          return;\n        }\n      }\n\n      this.ngRedux.dispatch({\n        type: UPDATE_LOCATION,\n        payload: location,\n      });\n    };\n\n    if (this.urlState) {\n      this.urlStateSubscription = this.urlState.subscribe(handleLocationChange);\n    }\n  }\n\n  private listenToReduxChanges() {\n    const handleLocationChange = (location: string) => {\n      if (this.initialLocation === undefined) {\n        // Wait for router to set initial location.\n        return;\n      }\n\n      const locationInStore = this.getLocationFromStore(true);\n      if (this.currentLocation === locationInStore) {\n        // Dont change router location if its equal to the one in the store.\n        return;\n      }\n\n      this.currentLocation = location;\n      this.router.navigateByUrl(location);\n    };\n\n    this.reduxSubscription = this.ngRedux\n      .select(state => this.selectLocationFromState(state))\n      .pipe(distinctUntilChanged())\n      .subscribe(handleLocationChange);\n  }\n}\n","import { ModuleWithProviders, NgModule } from '@angular/core';\nimport { UPDATE_LOCATION } from './actions';\nimport { RouterAction, routerReducer } from './reducer';\nimport { NgReduxRouter } from './router';\n\n@NgModule()\nexport class NgReduxRouterModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: NgReduxRouterModule,\n      providers: [NgReduxRouter],\n    };\n  }\n}\n\nexport { NgReduxRouter, RouterAction, routerReducer, UPDATE_LOCATION };\n","import { Action } from 'redux';\n\nimport { UPDATE_LOCATION } from './actions';\n\nexport const DefaultRouterState: string = '';\n\nexport interface RouterAction extends Action {\n  payload?: string;\n}\n\nexport function routerReducer(\n  state: string | undefined = DefaultRouterState,\n  action: RouterAction,\n): string {\n  switch (action.type) {\n    case UPDATE_LOCATION:\n      return action.payload || DefaultRouterState;\n    default:\n      return state;\n  }\n}\n"]}